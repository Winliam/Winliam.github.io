---
title: 关于动态库引起的同名符号问题
categories:
  - - 工作技能
    - C/C++笔记
date: 2022-03-26 19:05:39
tags:
  - 动态库
  - 符号表
  - 链接
---
## 问题描述
今天遇到一个奇怪的问题：

我要把一个进程A中的全局变量通过UDP协议转发给另一个进程B，但是这些全局变量都分散定义在A的若干动态库中。

本来想的是，先在A的主程序中用extern将这些全局变量声明为外部符号，然后正常使用这些符号即可。

但神奇的是，主程序中全局变量的地址和动态库中全局变量的地址竟然是不同的。

排查了半天，发现是因为定义这个全局变量的源文件参与了两次编译，形成了两个动态库，而这两个动态库又都参与了进程A的链接。

## 问题分析
首先，同一份源文件参与两次编译不是问题，也不难理解，可以等效认为把两份相同内容的源文件各自独立地编译成了两个不相干的动态库。

所以问题的关键是，主程序链接的两个动态库包含了同名符号，为啥不报错？

更深入一点，我们知道链接过程是链接器在针对目标文件执行**符号解析**和**重定位**两项任务。其中在进行**符号解析**时，从其最终结果来讲，肯定是不允许同名符号存在的。那么当参与链接的各个目标文件中存在同名符号时，链接器将如何处理呢？

> 这里说的目标文件泛指链接器的输入，按照CSAPP中的术语来说，具体包含**可重定位目标文件（.o文件）**，**静态库（.a文件）**和**共享目标文件（.so文件）**

### 基础知识回顾
- 源文件经过编译和汇编形成的binary文件，叫做可重定位目标文件。
- 

### 可重定位目标文件链接时的符号解析规则

### 静态库链接时的符号解析规则

### 动态库链接时的符号解析规则


## 结论



对于全局变量，都要被链接器管理（指编译器会为这个变量创建一个链接器符号，然后链接器才能为这个符号开展工作）
m自己定义的，只给自己用的
m自己定义的，大家都可以用的
别人定义的，m拿过来用的

对于局部变量
- 非静态变量，通过函数调用栈机制进行管理，链接器根本不知道有你这号人。
- 静态变量，视作全局变量（静态的还是静态的呢mark），被链接器管理。
