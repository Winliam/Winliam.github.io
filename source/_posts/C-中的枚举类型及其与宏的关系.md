---
title: C++中的枚举类型及其与宏的关系
categories:
  - - 工作技能
    - C/C++笔记
date: 2022-04-04 23:09:34
tags:
  - enum
  - 宏
  - 常数
  - enum hack
---
在编程时，如果想让一个变量只在规定范围内取值，就会用到enum类型，尤其是在跟switch语句配合使用时。

## 从size说起
enum类型的概念不难理解，但值得注意的是：**enum类型的大小如何，或者说占几个Bytes?**

在C语言中，一个enum类型的大小由编译器自行确定。确定规则是，确保enum取值范围中任一元素对应的整型值都能被表达。
```cpp
enum color1{
        YELLOW = 0x1,
        BLACK = 0x2
};
enum color2{
        YELLOW = 0x1122334455,
        BLACK = 0x2
};
// sizeof(color1) = 4;
// sizeof(color2) = 8;
```
产生编译器依赖显然不是件好事，所以C++中增加了显式指定enum类型大小的语法：
```cpp
enum color1 : int{
        YELLOW,
        BLACK
};
```

## enum hack
C++有了上述写法之后，又产生了这么一种off label的用法：
```cpp
enum : int{
        YELLOW = 1,
        BLACK = 2
};
```
这个写法其实是为了定义常数变量，直观理解上可以直接认为是宏定义即可。

深究的话，需要知道常用的定义常数变量的方式有三种：
1. const关键字，缺点是有可能要为该常量进行内存分配。因为其既然是一个显式定义的变量，那么就应当允许对其取址，这就意味着要占用内存。
2. 宏定义，内在逻辑是替换，所以没有了占内存的缺点，但是有同类信息没能聚合到一起的缺点。
3. anonymous enum，似乎是种完美的做法。一来，对于C++这种强类型的的语言，宏定义的方式绕过了类型检查，没能物尽其用的感觉。二来，enum定义同时完成了同类信息的聚合。
